<template src="./ITSchedule.html"></template>
<script setup lang="ts">
// Import necessary modules
import { ref, computed, onMounted } from 'vue';
import { generateClient } from 'aws-amplify/api';
import { listITOnCallEntries, listITContacts } from '@/graphql/queries';
import {
  createITContact,
  updateITContact,
  deleteITContact as deleteITContactMutation,
  createITOnCallEntry,
  updateITOnCallEntry,
} from '@/graphql/mutations';
import { format, startOfMonth, endOfMonth, eachDayOfInterval, getDay } from 'date-fns';
import { fetchAuthSession, getCurrentUser } from 'aws-amplify/auth';
import type { GraphQLResult } from '@aws-amplify/api-graphql';
// Generate Amplify API client
const client = generateClient();
// Interface defining the structure of a IT on-call entry
interface ITOnCallEntry {
  id?: string; // Unique identifier for the on-call entry (optional, generated by the backend)
  groupName: string; // Name of the group this entry belongs to (e.g., "IT")
  day: string; // Date of the on-call shift (YYYY-MM-DD format)
  contactID: string | null; // ID of the contact assigned to this shift (can be null if unassigned)
  contact?: { // Nested object containing contact details (optional, populated if contactID is set)
    id: string; // Contact's unique identifier
    email: string; // Contact's email address
    phone: string | null; // Contact's phone number (can be null)
    name: string; // Contact's name
    onCall: boolean; // Boolean indicating if the contact is currently on call
  };
  phone: string | null; // Phone number for the shift (can be null, might be different from contact's phone)
  startTime?: string | null; // Start time of the on-call shift (HH:MM format, can be null)
  timezone?: string | null; // Timezone for the on-call shift (can be null)
  selected?: boolean; // Flag to indicate if this entry is currently selected in the UI
}
// Interface defining the structure of a IT contact
interface ITContact {
  id: string; // Unique identifier for the contact
  email: string; // Contact's email address
  phone: string; // Contact's phone number
  name: string; // Contact's name
  onCall: boolean; // Boolean indicating if the contact is currently on call
}
// Interface for input to create a new IT on-call entry
interface CreateITOnCallEntryInput {
  groupName: string; // Required: Group name
  day: string; // Required: Day of the on-call shift (YYYY-MM-DD format)
  contactID?: string | null; // Optional: ID of the assigned contact
  phone?: string | null; // Optional: Phone number for the shift
  startTime?: string | null; // Optional: Start time of the shift
  timezone?: string | null; // Optional: Timezone of the shif
}
// Interface for input to update an existing IT on-call entry
interface UpdateITOnCallEntryInput {
  id: string; // Required: ID of the entry to update
  groupName?: string; // Optional: Group name
  day?: string; // Optional: Day of the shift
  contactID?: string; // Optional: ID of the assigned contact
  phone?: string; // Optional: Phone number for the shift
  startTime?: string; // Optional: Start time of the shift
  timezone?: string; // Optional: Timezone of the shift
}
// Props received from parent component
const props = defineProps<{ signOut: () => void, user: any }>();
// Reactive variables for the Vue component's state
const activeTab = ref('schedule'); // Currently active tab ('schedule' or 'contacts')
const selectedContact = ref<ITContact | null>(null);
const showModal = ref(false); // Flag to control the visibility of the modal dialog
const editIndex = ref<number | null>(null); // Index of the contact currently being edited
const form = ref<ITContact>({ id: '', email: '', phone: '', name: '', onCall: false }); // Form data for adding/editing contacts
const errorMessage = ref(''); // Error message to display to the user
const contacts = ref<ITContact[]>([]); // Array to store contact information
const onCallList = ref<ITOnCallEntry[]>([]); // Array to store on-call schedule entries
  const timeOptions = ref(generateTimeOptions()); // Array of time options for the UI
const timezoneOptions = ref(['GMT', 'EST', 'PST', 'BST', 'CET']); // Array of timezone options
const selectedMonth = ref(new Date().getMonth()); // Currently selected month
const selectedYear = ref(new Date().getFullYear()); // Currently selected year
const isAdmin = ref(false); // Flag to indicate if the user is an administrator
const isLoading = ref(false); // Initially not loading
// State to hold timezone and start time settings for each month
const monthlySettings = ref<Record<number, { timezone: string; startTime: string }>>({});
// Initialize default settings for each month (0-11 representing January to December)
for (let i = 0; i < 12; i++) {
  monthlySettings.value[i] = {
    timezone: 'GMT',   // Default timezone
    startTime: '07:30' // Default start time
  };
}
// Array of month names for UI display
const months = [
  'January', 'February', 'March', 'April', 'May', 'June',
  'July', 'August', 'September', 'October', 'November', 'December'
];
// Array of years for UI selection (last 10 years)
const years = Array.from({ length: 10 }, (_, i) => new Date().getFullYear() + i);

// Function to generate time options (HH:MM format)
function generateTimeOptions() {
  const times = [];
  for (let i = 0; i < 24; i++) {
    for (let j = 0; j < 60; j += 30) {
      const hour = i < 10 ? `0${i}` : i;
      const minute = j < 10 ? `0${j}` : j;
      times.push(`${hour}:${minute}`);
    }
  }
  return times;
}
// Function to handle selecting a contact
const handleContactSelect = (contact: ITContact) => {
  selectedContact.value = contact; // Set the selected contact
};

// Computed property for displaying the phone number of the selected contact
const selectedContactPhone = computed(() => {
  return selectedContact.value ? selectedContact.value.phone : ''; // Return the phone number or an empty string
});

// Function to fetch IT contact information from the backend
const fetchITContacts = async () => {
  console.log("Fetching IT contacts...");
  try {
    const result = await client.graphql({ query: listITContacts }) as GraphQLResult<any>;
    if (result.data) {
      contacts.value = result.data.listITContacts.items;
      console.log("IT contacts fetched:", contacts.value);
    } else {
      console.error("Error fetching IT contacts:", result.errors);
      throw new Error("Error fetching IT contacts");
    }
  } catch (error) {
    console.error("Error in fetchITContacts:", error);
  }
};
// Function to fetch IT on-call entries from the backend
const fetchITOnCallEntries = async () => {
  console.log("Fetching IT on-call entries...");
  try {
    const result = await client.graphql({ query: listITOnCallEntries }) as GraphQLResult<{ listITOnCallEntries: { items: ITOnCallEntry[] } }>;
    if (result.data) {
      onCallList.value = result.data.listITOnCallEntries.items;
      console.log("IT on-call entries fetched:", onCallList.value);
    } else {
      console.error("Error fetching IT on-call entries:", result.errors);
      throw new Error("Error fetching IT on-call entries");
    }
  } catch (error) {
    console.error("Error in fetchITOnCallEntries:", error);
  }
};
// Function to save or update IT contact information
const saveContact = async () => {
  const e164Regex = /^\+?[1-9]\d{1,14}$/; // E.164 format validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; // Basic email validation

  // Email validation
  if (!emailRegex.test(form.value.email)) {
    errorMessage.value = 'Please enter a valid email address.';
    return;
  }

  // Check if this is an update operation
  if (editIndex.value === null) {
    // Only check for duplicates when creating a new contact
    const duplicateName = contacts.value.find(contact => contact.name.toLowerCase() === form.value.name.toLowerCase());
    if (duplicateName) {
      errorMessage.value = 'Contact with this name already exists.';
      return;
    }

    const duplicatePhone = contacts.value.find(contact => contact.phone === form.value.phone);
    if (duplicatePhone) {
      errorMessage.value = 'Contact with this phone number already exists.';
      return;
    }
  }
  
  try {
    const contactInput = {
      email: form.value.email,
      phone: form.value.phone,
      name: form.value.name,
      onCall: form.value.onCall,
    };

    // Update existing contact if editIndex is set, otherwise create a new contact
    if (editIndex.value !== null) {
      // Update logic: add existing contact ID
      await client.graphql({
        query: updateITContact,
        variables: { input: { ...contactInput, id: contacts.value[editIndex.value].id } }
      });
    } else {
      // Create logic
      await client.graphql({
        query: createITContact,
        variables: { input: contactInput }
      });
    }
    
    showModal.value = false; // Close the modal
    await fetchITContacts(); // Refresh the contact list
  } catch (error) {
    console.error("Error saving contact:", error);
    errorMessage.value = 'An error occurred while saving the contact.';
  }
};
// Function to delete a contact
const deleteContact = async (index: number) => {
  const contactIdToDelete = contacts.value[index].id; // Get the ID of the contact to be deleted
  try {
    // Delete the contact from the database
    await client.graphql({
      query: deleteITContactMutation,
      variables: { input: { id: contactIdToDelete } }
    });
    // Remove references to the deleted contact from the onCallList
    onCallList.value.forEach(entry => {
      if (entry.contactID === contactIdToDelete) {
        entry.contactID = ''; // Clear the contactID
        entry.phone = ''; // Clear the associated phone number
      }
    });
    await fetchITContacts(); // Refresh the contact list
  } catch (error) {
    console.error("Error deleting contact:", error);
    errorMessage.value = 'An error occurred while deleting the contact.';
  }
};
// Function to update the phone number for a IT on-call entry
const updatePhoneNumber = (index: number) => {
  const contactName = onCallList.value[index].contact;
  if (typeof contactName === 'string') {
    const contact = contacts.value.find(c => c.name === contactName);
    if (contact) {
      onCallList.value[index].phone = contact.phone;
    }
  }
};
// Function to generate the IT on-call calendar for the selected month and year
const generateCalendar = async () => {
  onCallList.value = [];
  const now = new Date(selectedYear.value, selectedMonth.value);
  const start = startOfMonth(now);
  const end = endOfMonth(now);
  const days = eachDayOfInterval({ start, end });
  const daysOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  let existingEntries: ITOnCallEntry[] = [];
  try {
    const result = await client.graphql({ query: listITOnCallEntries }) as GraphQLResult<{ listITOnCallEntries: { items: ITOnCallEntry[] } }>;
    if (result.data) {
      existingEntries = result.data.listITOnCallEntries.items;
    }
  } catch (error) {
    console.error('Error fetching IT on-call entries:', error);
  }
  // Generate the base calendar structure
  const baseCalendar = days.map(day => ({
    id: undefined,
    groupName: 'IT',
    day: format(day, 'yyyy-MM-dd'),
    dayOfWeek: daysOfWeek[getDay(day)],
    contactID: '',
    phone: null,
    startTime: monthlySettings.value[selectedMonth.value].startTime,
    timezone: monthlySettings.value[selectedMonth.value].timezone,
    selected: false,
    contact: undefined
  }));
  // Merge existing entries with the base calendar
  onCallList.value = baseCalendar.map(baseEntry => {
    const existingEntry = existingEntries.find(entry => entry.day === baseEntry.day);
    return existingEntry
      ? { ...baseEntry, ...existingEntry } // Merge existing data, preserving phone number
      : baseEntry;
  });
  // Update onCall status in contacts
  contacts.value.forEach(contact => {
    contact.onCall = onCallList.value.some(entry => entry.contactID === contact.id);
  });
  try {
    const result = await client.graphql({ query: listITOnCallEntries }) as GraphQLResult<{ listITOnCallEntries: { items: ITOnCallEntry[] } }>;
    if (result.data) {
      const existingEntries = result.data.listITOnCallEntries.items;
      // Merge existing entries with the newly generated calendar entries
      onCallList.value = onCallList.value.map(newEntry => {
        const existingEntry = existingEntries.find(item => item.day === newEntry.day);
        return existingEntry ? { ...newEntry, ...existingEntry } : newEntry;
      });
      // Update onCall status in contacts based on the merged onCallList
      contacts.value.forEach(contact => {
        contact.onCall = onCallList.value.some(entry => entry.contactID === contact.id);
      });
    }
  } catch (error) {
    console.error('Error fetching IT on-call entries:', error);
  }
};
// Function to handle day selection on the calendar
const selectDay = (entry: ITOnCallEntry) => {
  entry.selected = !entry.selected; // Toggle the selected status
  // Ensure only one day is selected at a time
  onCallList.value.forEach(item => {
    if (item !== entry) item.selected = false;
  });
};

// Function to check if the current user is an administrator
const checkAdmin = async () => {
  try {
    const user = await getCurrentUser(); // Get the current user from Amplify Auth
    const session = await fetchAuthSession(); // Get the current auth session
    if (!session.tokens) {
      console.error("No tokens found in the session.");
      return;
    }
    const groups = session.tokens.accessToken.payload["cognito:groups"]; // Extract Cognito groups from the access token
    if (Array.isArray(groups)) {
      isAdmin.value = groups.includes("ITAdmin"); // Check if the user belongs to the "ITAdmin" group
    } else {
      console.error("Groups is not an array:", groups);
    }
  } catch (error) {
    console.error("Error checking if user is admin:", error);
  }
};
// Function to open the modal dialog for adding or editing contacts
const openModal = (index: number | null = null) => {
  editIndex.value = index; // Set the index of the contact being edited
  if (index !== null) {
    form.value = { ...contacts.value[index] }; // Load contact details into the form
  } else {
    form.value = { id: '', email: '', phone: '', name: '', onCall: false }; // Clear the form for new contact
  }
  showModal.value = true; // Show the modal
};
// Function to fetch IT on-call entries and reload the schedule
const fetchAndReloadSchedule = async () => {
  await fetchITOnCallEntries();
  await generateCalendar(); // Update the calendar after fetching entries
};
// Lifecycle hook that runs after the component is mounted
onMounted(async () => {
  console.log('Component mounted');
  try {
    await fetchITContacts(); 
    // Get the current month (0-indexed)
    const currentMonth = new Date().getMonth(); 
    selectedMonth.value = currentMonth; // Set the selectedMonth to the current month
    selectedYear.value = new Date().getFullYear(); // set selected year to current year
    await fetchAndReloadSchedule(); // Fetch on-call entries and generate the calendar for the current month
    loadSettings(); // Load monthly settings
    await checkAdmin(); // Check admin status
  } catch (error) {
    console.error("Error during mounted hook:", error);
  }
});
// Function to load monthly settings from the backend
const loadSettings = async () => {
  try {
    const result = await client.graphql({ query: listITOnCallEntries });
    if (result.data) {
      const entries = result.data.listITOnCallEntries.items;
      if (entries.length > 0) {
        const firstEntry = entries[0]; // Use the first entry to get default settings
        // Set timezone and startTime for each month based on the first entry
        Object.keys(monthlySettings.value).forEach(month => {
          monthlySettings.value[Number(month)] = { // Convert month key (string) to number
            timezone: firstEntry.timezone || 'GMT', // Use timezone from first entry or default to 'GMT'
            startTime: firstEntry.startTime || '07:30' // Use startTime from first entry or default to '07:30'
          };
        });
      }
    }
  } catch (error) {
    console.error("Error loading settings:", error);
  }
};

// Function to save the IT on-call schedule to the backend
const saveSchedule = async () => {
  if (!confirm('Are you sure you want to save the schedule?')) return; // Confirmation prompt
  console.log("Attempting to save the following entries:", JSON.stringify(onCallList.value, null, 2));
  try {
    await Promise.all(onCallList.value.map(async entry => {
      // Prepare entry data for saving
      let entryData: CreateITOnCallEntryInput | UpdateITOnCallEntryInput = {
        groupName: entry.groupName,
        day: entry.day,
        contactID: entry.contactID || null,
        phone: entry.phone || null,
        startTime: monthlySettings.value[selectedMonth.value].startTime || null,
        timezone: monthlySettings.value[selectedMonth.value].timezone || null
      };
      if (entry.id) {  // If entry has an ID, it's an update
        entryData = {
          ...entryData,
          id: entry.id // Include ID for update operations
        } as UpdateITOnCallEntryInput; // Type assertion
      }
      console.log("Saving entry data:", entryData); // Log the entry data being saved
      // Perform either update or create operation based on whether the entry has an ID
      if (entry.id) {
        await client.graphql({
          query: updateITOnCallEntry,
          variables: { input: entryData as UpdateITOnCallEntryInput },
        });
      } else {
        await client.graphql({
          query: createITOnCallEntry,
          variables: { input: entryData as CreateITOnCallEntryInput },
        });
      }
    }));
    alert('Schedule saved successfully!'); // Success message
    await generateCalendar(); // Refresh the calendar
  } catch (error: unknown) {
    console.error("Error saving schedule:", error);
    // Handle errors appropriately, providing informative messages to the user.
    if (error instanceof Error) {
      alert(`An error occurred while saving the schedule: ${error.message}`);
    } else {
      alert('An unknown error occurred while saving the schedule.');
    }
  }
};
</script>
<style src="./OnCallApplication.css" scoped></style>


